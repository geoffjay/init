#!/bin/bash
# scripts/prepare - Bootstrap script for OS initialization
# This script prepares a minimal environment for OS initialization and configuration
set -euo pipefail

# Configuration
readonly SCRIPT_VERSION="1.0.0"
readonly ASDF_VERSION="v0.18.0"
readonly PROJECT_REPO="https://github.com/geoffjay/init"
readonly PROJECTS_DIR="$HOME/Projects"
readonly PROJECT_DIR="$PROJECTS_DIR/init"
readonly ASDF_DIR="$HOME/.asdf"

# Global variables
OS=""
PKG_MGR=""
ARCH=""
SELECTED_SHELL=""

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Show help information
show_help() {
    cat << EOF
OS Bootstrap Script (version $SCRIPT_VERSION)

DESCRIPTION:
    This script prepares a minimal environment for OS initialization and configuration.
    It installs git, asdf (via Homebrew on macOS, git clone on Linux), and homebrew (on macOS),
    then clones the project repository.

USAGE:
    $0 [OPTIONS]

OPTIONS:
    -h, --help          Show this help message
    -v, --version       Show version information
    --dry-run           Show what would be done without making changes
    --debug             Enable debug output
    --shell=SHELL       Select shell to install, set as default, and configure (bash|zsh)
                        If different from current shell, you'll be prompted to continue
                        in the new shell or complete setup in the current shell
                        Default: auto-detect current shell

ENVIRONMENT VARIABLES:
    ALLOW_ROOT      Set to 'true' to allow running as root (not recommended)
    PROJECT_REPO    Override the default project repository URL

SUPPORTED PLATFORMS:
    - Ubuntu, Debian, Pop!_OS (apt-based)
    - Alpine Linux (apk-based)  
    - macOS (with Homebrew)

EXAMPLES:
    # Standard installation
    $0

    # Run via web (typical usage)
    wget -q -O - https://raw.githubusercontent.com/geoffjay/init/main/scripts/prepare | bash

    # Install and configure zsh as the shell
    $0 --shell=zsh

    # Install and configure bash as the shell
    $0 --shell=bash

    # Dry run to see what would be installed
    $0 --dry-run

For more information, visit: https://github.com/geoffjay/init
EOF
}

# Show version information
show_version() {
    echo "OS Bootstrap Script version $SCRIPT_VERSION"
    echo "asdf version: $ASDF_VERSION"
    echo "Project repository: $PROJECT_REPO"
}

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

log_debug() {
    if [[ "${DEBUG:-}" == "true" ]]; then
        echo -e "${YELLOW}[DEBUG]${NC} $*" >&2
    fi
}

# Cleanup function for error handling
cleanup_on_error() {
    local exit_code=$?
    log_error "Script failed with exit code $exit_code"
    log_error "Cleaning up any partial installations..."
    
    # Remove partial asdf installation if it exists but is broken
    if [[ -d "$ASDF_DIR" ]] && ! command -v asdf >/dev/null 2>&1; then
        log_warn "Removing partial asdf installation at $ASDF_DIR"
        rm -rf "$ASDF_DIR" || true
    fi
    
    log_error "Bootstrap process failed. Please check the error messages above."
    log_error "You can re-run this script after fixing any issues."
    exit $exit_code
}

# Handle interruption signals
cleanup_on_interrupt() {
    log_warn "Script interrupted by user"
    cleanup_on_error
}

# Platform detection
detect_platform() {
    log_info "Detecting platform..."
    log_debug "OSTYPE: $OSTYPE"
    
    # Detect architecture
    ARCH=$(uname -m)
    log_debug "Architecture: $ARCH"
    case $ARCH in
        x86_64|amd64) ARCH="x86_64" ;;
        arm64|aarch64) ARCH="arm64" ;;
        *) 
            log_error "Unsupported architecture: $ARCH"
            exit 1
            ;;
    esac
    
    # Detect OS
    if [[ "$OSTYPE" == "darwin"* ]]; then
        OS="macos"
        log_info "Detected macOS ($ARCH)"
    elif [[ -f /etc/os-release ]]; then
        # Source the os-release file
        . /etc/os-release
        log_debug "OS ID: $ID, Pretty Name: ${PRETTY_NAME:-$ID}"
        case $ID in
            ubuntu|debian|pop)
                OS="debian-based"
                PKG_MGR="apt"
                log_info "Detected $PRETTY_NAME (Debian-based, $ARCH)"
                ;;
            alpine)
                OS="alpine"
                PKG_MGR="apk"
                log_info "Detected $PRETTY_NAME (Alpine, $ARCH)"
                ;;
            *)
                log_error "Unsupported Linux distribution: ${PRETTY_NAME:-$ID} ($ID)"
                log_error "Supported distributions: Ubuntu, Debian, Pop!_OS, Alpine Linux"
                exit 1
                ;;
        esac
    else
        log_error "Unsupported operating system: $OSTYPE"
        log_error "Supported systems: Linux (Ubuntu/Debian/Pop!_OS/Alpine), macOS"
        exit 1
    fi
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    # Check for internet connectivity
    log_debug "Testing connectivity to GitHub..."
    if ! curl -s --head --connect-timeout 10 https://github.com >/dev/null; then
        log_error "No internet connectivity or GitHub is unreachable"
        log_error "This script requires internet access to download tools"
        exit 1
    fi
    log_debug "Internet connectivity verified"
    
    # Check if running as root (warn but allow with ALLOW_ROOT)
    if [[ $EUID -eq 0 ]]; then
        if [[ "${ALLOW_ROOT:-}" != "true" ]]; then
            log_warn "Running as root is not recommended"
            log_warn "If you must run as root, set ALLOW_ROOT=true environment variable"
            log_warn "Continuing in 5 seconds... (Ctrl+C to cancel)"
            sleep 5
        else
            log_warn "Running as root (ALLOW_ROOT=true set)"
        fi
    fi
    
    # Check for required system commands
    local required_commands=("curl" "tar")
    if [[ "$OS" != "alpine" ]]; then
        required_commands+=("sudo")
    fi
    
    for cmd in "${required_commands[@]}"; do
        log_debug "Checking for command: $cmd"
        if ! command -v "$cmd" >/dev/null 2>&1; then
            log_error "Required command not found: $cmd"
            exit 1
        fi
    done
    
    # Check disk space (require at least 1GB free)
    local available_space
    if command -v df >/dev/null 2>&1; then
        available_space=$(df "$HOME" | tail -1 | awk '{print $4}')
        log_debug "Available disk space: ${available_space}KB"
        if [[ $available_space -lt 1048576 ]]; then # 1GB in KB
            log_warn "Low disk space detected (less than 1GB available)"
            log_warn "Installation may fail due to insufficient space"
        fi
    fi
    
    log_success "Prerequisites check completed"
}

# Verify tool installation
verify_installation() {
    local tool=$1
    local version_cmd=$2
    
    if ! command -v "$tool" >/dev/null 2>&1; then
        log_error "$tool installation failed or not in PATH"
        return 1
    fi
    
    if [[ -n "$version_cmd" ]]; then
        local version_output
        version_output=$(eval "$version_cmd" 2>/dev/null || echo "version check failed")
        log_success "$tool installed successfully ($version_output)"
    else
        log_success "$tool installed successfully"
    fi
    
    return 0
}

# Install shell
install_shell() {
    local target_shell="$1"
    log_info "Installing and configuring shell: $target_shell"
    
    # Check what shell we're currently running in
    local current_running_shell
    # Try multiple methods to detect the current shell
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        current_running_shell="zsh"
    elif [[ -n "${BASH_VERSION:-}" ]]; then
        current_running_shell="bash"
    else
        # Fall back to checking parent process
        local parent_pid
        parent_pid=$(ps -o ppid= -p $$ 2>/dev/null | tr -d ' ')
        if [[ -n "$parent_pid" ]]; then
            current_running_shell=$(ps -p "$parent_pid" -o comm= 2>/dev/null | sed 's/^-//' || echo "unknown")
        else
            current_running_shell="unknown"
        fi
    fi
    
    # Check the system's default shell setting
    local system_default_shell
    system_default_shell=$(basename "$SHELL")
    
    log_debug "Currently running shell: $current_running_shell"
    log_debug "Target shell: $target_shell"
    log_debug "System default shell (SHELL env var): $system_default_shell"
    
    # Check if shell is already installed
    if command -v "$target_shell" >/dev/null 2>&1; then
        local shell_version
        case "$target_shell" in
            bash)
                shell_version=$(bash --version | head -n1 2>/dev/null || echo "unknown")
                ;;
            zsh)
                shell_version=$(zsh --version 2>/dev/null || echo "unknown")
                ;;
        esac
        log_info "$target_shell is already installed ($shell_version)"
    else
        if [[ "${DRY_RUN:-}" == "true" ]]; then
            log_info "[DRY RUN] Would install $target_shell via $PKG_MGR"
        else
            log_info "Installing $target_shell..."
            case $OS in
                debian-based)
                    sudo apt update -qq
                    sudo apt install -y "$target_shell"
                    ;;
                alpine)
                    if [[ $EUID -eq 0 ]]; then
                        apk update
                        apk add "$target_shell"
                    else
                        sudo apk update
                        sudo apk add "$target_shell"
                    fi
                    ;;
                macos)
                    # bash and zsh are usually pre-installed on macOS
                    if ! command -v "$target_shell" >/dev/null 2>&1; then
                        log_info "Installing $target_shell via Homebrew..."
                        brew install "$target_shell"
                    fi
                    ;;
            esac
            
            verify_installation "$target_shell" ""
        fi
    fi
    
    # Check if we're already running in the target shell
    if [[ "$current_running_shell" == "$target_shell" ]]; then
        log_info "Already running in $target_shell"
        
        # Still check if we need to set it as the system default
        if [[ "$system_default_shell" != "$target_shell" ]]; then
            if [[ "${DRY_RUN:-}" == "true" ]]; then
                log_info "[DRY RUN] Would set $target_shell as system default shell"
            else
                log_info "Setting $target_shell as system default shell..."
                local shell_path
                shell_path=$(command -v "$target_shell")
                
                # Add shell to /etc/shells if not already present
                if ! grep -q "^$shell_path$" /etc/shells 2>/dev/null; then
                    log_info "Adding $shell_path to /etc/shells"
                    echo "$shell_path" | sudo tee -a /etc/shells >/dev/null
                fi
                
                # Change user's default shell
                if command -v chsh >/dev/null 2>&1; then
                    chsh -s "$shell_path"
                    log_success "System default shell set to $target_shell"
                    log_info "Note: The change will take effect for new login sessions"
                else
                    log_warn "chsh command not available - you may need to change your shell manually"
                fi
            fi
        else
            log_info "$target_shell is already the system default shell"
        fi
        return 0
    fi
    
    # We need to switch to the target shell
    if [[ "$system_default_shell" != "$target_shell" ]]; then
        if [[ "${DRY_RUN:-}" == "true" ]]; then
            log_info "[DRY RUN] Would change system default shell from $system_default_shell to $target_shell"
            log_info "[DRY RUN] Would prompt user about continuing with shell switch"
        else
            log_info "Setting $target_shell as system default shell..."
            local shell_path
            shell_path=$(command -v "$target_shell")
            
            # Add shell to /etc/shells if not already present
            if ! grep -q "^$shell_path$" /etc/shells 2>/dev/null; then
                log_info "Adding $shell_path to /etc/shells"
                echo "$shell_path" | sudo tee -a /etc/shells >/dev/null
            fi
            
            # Change user's default shell
            if command -v chsh >/dev/null 2>&1; then
                chsh -s "$shell_path"
                log_success "System default shell changed to $target_shell"
                
                # Ask user how they want to proceed
                echo
                log_warn "SHELL CHANGE DETECTED:"
                log_warn "You've switched from $system_default_shell to $target_shell as your default shell."
                log_warn "Currently running: $current_running_shell → switching to: $target_shell"
                echo
                echo "To continue the bootstrap process, you have two options:"
                echo
                echo "  Option A: Continue in the new shell (recommended)"
                echo "            This will re-run the script using $target_shell"
                echo
                echo "  Option B: Complete bootstrap in current shell, then logout/login"
                echo "            Configuration will be applied to $target_shell but you'll need"
                echo "            to logout and login for it to take effect"
                echo
                echo -n "Which option would you prefer? [A/b]: "
                read -r choice
                choice=${choice:-A}
                
                case "$choice" in
                    [Aa]*)
                        log_info "Continuing bootstrap process in $target_shell..."
                        echo
                        # Re-execute the script with the same arguments in the new shell
                        local script_args=()
                        # Reconstruct the original arguments
                        [[ "${DRY_RUN:-}" == "true" ]] && script_args+=("--dry-run")
                        [[ "${DEBUG:-}" == "true" ]] && script_args+=("--debug")
                        [[ -n "$SELECTED_SHELL" ]] && script_args+=("--shell=$SELECTED_SHELL")
                        
                        # Get the full path to the current script
                        local script_path
                        script_path=$(realpath "$0")
                        
                        log_info "Executing: exec $shell_path $script_path ${script_args[*]}"
                        exec "$shell_path" "$script_path" "${script_args[@]}"
                        ;;
                    [Bb]*)
                        log_info "Continuing bootstrap in current shell..."
                        log_warn "Remember to logout and login after completion for shell change to take effect"
                        echo
                        ;;
                    *)
                        log_warn "Invalid choice, continuing in current shell..."
                        echo
                        ;;
                esac
            else
                log_warn "chsh command not available - you may need to change your shell manually"
            fi
        fi
    else
        # System default is already correct, just need to switch running shell
        if [[ "${DRY_RUN:-}" == "true" ]]; then
            log_info "[DRY RUN] Would switch from $current_running_shell to $target_shell"
        else
            log_info "Switching from $current_running_shell to $target_shell..."
            local shell_path
            shell_path=$(command -v "$target_shell")
            
            # Re-execute the script with the same arguments in the new shell
            local script_args=()
            [[ "${DRY_RUN:-}" == "true" ]] && script_args+=("--dry-run")
            [[ "${DEBUG:-}" == "true" ]] && script_args+=("--debug")
            [[ -n "$SELECTED_SHELL" ]] && script_args+=("--shell=$SELECTED_SHELL")
            
            # Get the full path to the current script
            local script_path
            script_path=$(realpath "$0")
            
            log_info "Executing: exec $shell_path $script_path ${script_args[*]}"
            exec "$shell_path" "$script_path" "${script_args[@]}"
        fi
    fi
}

# Install git
install_git() {
    log_info "Installing git..."
    
    # Check if git is already installed
    if command -v git >/dev/null 2>&1; then
        local git_version
        git_version=$(git --version 2>/dev/null || echo "unknown")
        log_info "git is already installed ($git_version)"
        return 0
    fi
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "[DRY RUN] Would install git via $PKG_MGR"
        return 0
    fi
    
    case $OS in
        debian-based)
            log_info "Updating package cache..."
            sudo apt update -qq
            log_info "Installing git via apt..."
            sudo apt install -y git
            ;;
        alpine)
            log_info "Updating package cache..."
            if [[ $EUID -eq 0 ]]; then
                apk update
                apk add git
            else
                sudo apk update
                sudo apk add git
            fi
            ;;
        macos)
            # On macOS, git is usually installed with Xcode command line tools
            if ! command -v git >/dev/null 2>&1; then
                log_info "Installing Xcode command line tools..."
                xcode-select --install
                log_info "Please complete the Xcode command line tools installation and re-run this script"
                exit 1
            fi
            ;;
    esac
    
    verify_installation "git" "git --version"
}

# Install asdf
install_asdf() {
    log_info "Installing asdf..."
    
    # Check if asdf is already installed and working
    if command -v asdf >/dev/null 2>&1; then
        local asdf_version
        asdf_version=$(asdf version 2>/dev/null || echo "unknown")
        log_info "asdf is already installed ($asdf_version)"
        
        # Source asdf if not already sourced (for plugin installation)
        if [[ -z "${ASDF_DIR_WAS_SET:-}" ]]; then
            # Try to source existing asdf installation
            if [[ -f "$HOME/.asdf/asdf.sh" ]]; then
                # shellcheck source=/dev/null
                . "$HOME/.asdf/asdf.sh" 2>/dev/null || true
                export ASDF_DIR_WAS_SET=1
            elif [[ -f "/opt/homebrew/opt/asdf/libexec/asdf.sh" ]]; then
                # shellcheck source=/dev/null
                . "/opt/homebrew/opt/asdf/libexec/asdf.sh" 2>/dev/null || true
                export ASDF_DIR_WAS_SET=1
            elif [[ -f "/usr/local/opt/asdf/libexec/asdf.sh" ]]; then
                # shellcheck source=/dev/null
                . "/usr/local/opt/asdf/libexec/asdf.sh" 2>/dev/null || true
                export ASDF_DIR_WAS_SET=1
            fi
        fi
        
        # Install plugins even if asdf is already installed
        install_asdf_plugins
        return 0
    fi
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        case $OS in
            macos)
                log_info "[DRY RUN] Would install asdf via Homebrew"
                ;;
            debian-based|alpine)
                log_info "[DRY RUN] Would install asdf via git clone to $ASDF_DIR"
                ;;
        esac
        log_info "[DRY RUN] Would install asdf plugins: python, uv, direnv"
        return 0
    fi
    
    # Install asdf using appropriate method for each platform
    case $OS in
        macos)
            log_info "Installing asdf via Homebrew..."
            brew install asdf
            
            # Source asdf for this script only if not already sourced
            if [[ -z "${ASDF_DIR_WAS_SET:-}" ]]; then
                if [[ -f "/opt/homebrew/opt/asdf/libexec/asdf.sh" ]]; then
                    # Apple Silicon
                    # shellcheck source=/dev/null
                    . "/opt/homebrew/opt/asdf/libexec/asdf.sh"
                    export ASDF_DIR_WAS_SET=1
                elif [[ -f "/usr/local/opt/asdf/libexec/asdf.sh" ]]; then
                    # Intel
                    # shellcheck source=/dev/null
                    . "/usr/local/opt/asdf/libexec/asdf.sh"
                    export ASDF_DIR_WAS_SET=1
                else
                    log_error "Could not find asdf installation after Homebrew install"
                    exit 1
                fi
            fi
            ;;
        debian-based|alpine)
            log_info "Installing asdf via git clone (Linux)..."
            install_asdf_from_git
            return 0
            ;;
    esac
    
    # Install required asdf plugins
    install_asdf_plugins
    
    verify_installation "asdf" "asdf version"
}

# Install asdf from git (fallback method)
install_asdf_from_git() {
    log_info "Installing asdf from git repository..."
    
    # Remove existing asdf directory if it exists but is broken
    if [[ -d "$ASDF_DIR" ]]; then
        log_warn "Removing existing asdf directory (appears to be broken)"
        rm -rf "$ASDF_DIR"
    fi
    
    # Clone asdf repository and checkout specific version
    log_info "Cloning asdf repository..."
    git clone --quiet https://github.com/asdf-vm/asdf.git "$ASDF_DIR"
    
    # Checkout the specific version (avoids detached HEAD warnings)
    log_info "Checking out asdf version $ASDF_VERSION..."
    cd "$ASDF_DIR"
    git checkout --quiet "$ASDF_VERSION"
    cd - >/dev/null
    
    # Add asdf to PATH for this script
    export PATH="$ASDF_DIR/bin:$PATH"
    
    # Source asdf only if not already sourced (to avoid readonly variable error)
    if [[ -z "${ASDF_DIR_WAS_SET:-}" ]]; then
        # Source asdf.sh in a way that avoids readonly variable conflicts
        # shellcheck source=/dev/null
        if ! . "$ASDF_DIR/asdf.sh" 2>/dev/null; then
            log_debug "Standard sourcing failed, likely due to readonly ASDF_DIR"
            # Alternative: just ensure the functions are available via PATH
            export PATH="$ASDF_DIR/bin:$ASDF_DIR/shims:$PATH"
        fi
        export ASDF_DIR_WAS_SET=1
    fi
    
    # Install required asdf plugins
    install_asdf_plugins
    
    verify_installation "asdf" "asdf version"
}

# Install required asdf plugins
install_asdf_plugins() {
    log_info "Installing asdf plugins..."
    
    # Install python plugin
    if ! asdf plugin list | grep -q "^python$"; then
        log_info "Adding python plugin..."
        asdf plugin add python
        log_success "Added python plugin to asdf"
    else
        log_info "python plugin already installed"
    fi
    
    # Install uv plugin  
    if ! asdf plugin list | grep -q "^uv$"; then
        log_info "Adding uv plugin..."
        asdf plugin add uv
        log_success "Added uv plugin to asdf"
    else
        log_info "uv plugin already installed"
    fi
    
    # Install direnv plugin
    if ! asdf plugin list | grep -q "^direnv$"; then
        log_info "Adding direnv plugin..."
        asdf plugin add direnv
        log_success "Added direnv plugin to asdf"
    else
        log_info "direnv plugin already installed"
    fi
}

# Install Homebrew (macOS only)
install_homebrew() {
    log_info "Installing Homebrew..."
    
    # Check if brew is already installed
    if command -v brew >/dev/null 2>&1; then
        local brew_version
        brew_version=$(brew --version | head -n1 2>/dev/null || echo "unknown")
        log_info "Homebrew is already installed ($brew_version)"
        return 0
    fi
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "[DRY RUN] Would install Homebrew"
        return 0
    fi
    
    # Install Homebrew
    log_info "Downloading and installing Homebrew..."
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    
    # Add Homebrew to PATH for this script
    if [[ -f "/opt/homebrew/bin/brew" ]]; then
        # Apple Silicon
        export PATH="/opt/homebrew/bin:$PATH"
    elif [[ -f "/usr/local/bin/brew" ]]; then
        # Intel
        export PATH="/usr/local/bin:$PATH"
    fi
    
    verify_installation "brew" "brew --version | head -n1"
}

# Setup project environment
setup_project() {
    log_info "Setting up project environment..."
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "[DRY RUN] Would create directory: $PROJECTS_DIR"
        log_info "[DRY RUN] Would clone repository: $PROJECT_REPO"
        return 0
    fi
    
    # Create Projects directory if it doesn't exist
    if [[ ! -d "$PROJECTS_DIR" ]]; then
        log_info "Creating Projects directory at $PROJECTS_DIR"
        mkdir -p "$PROJECTS_DIR"
    else
        log_info "Projects directory already exists at $PROJECTS_DIR"
    fi
    
    # Clone project repository if it doesn't exist
    if [[ ! -d "$PROJECT_DIR" ]]; then
        log_info "Cloning project repository..."
        git clone "$PROJECT_REPO" "$PROJECT_DIR"
        log_success "Project cloned to $PROJECT_DIR"
    else
        log_info "Project directory already exists at $PROJECT_DIR"
        # Update existing repository
        log_info "Updating existing repository..."
        cd "$PROJECT_DIR"
        git pull origin main || git pull origin master || log_warn "Could not update repository"
        cd - >/dev/null
    fi
    
    # Verify project structure
    if [[ ! -f "$PROJECT_DIR/.tool-versions" ]]; then
        log_error "Project appears to be incomplete (missing .tool-versions)"
        log_error "Please check the repository: $PROJECT_REPO"
        exit 1
    fi
    
    log_success "Project environment setup completed"
}

# Setup shell integration
setup_shell_integration() {
    log_info "Setting up shell integration..."
    
    local shell_name=""
    local shell_config_file=""
    
    # Determine which shell to configure
    if [[ -n "$SELECTED_SHELL" ]]; then
        shell_name="$SELECTED_SHELL"
        log_info "Configuring selected shell: $shell_name"
    else
        # Auto-detect shell
        if [[ -n "${BASH_VERSION:-}" ]]; then
            shell_name="bash"
        elif [[ -n "${ZSH_VERSION:-}" ]]; then
            shell_name="zsh"
        else
            # Try to detect from SHELL environment variable
            case "${SHELL:-}" in
                */bash) shell_name="bash" ;;
                */zsh) shell_name="zsh" ;;
                *) 
                    log_warn "Could not detect shell, defaulting to bash"
                    shell_name="bash"
                    ;;
            esac
        fi
        log_info "Auto-detected shell: $shell_name"
    fi
    
    # Determine shell configuration file based on shell type
    case "$shell_name" in
        bash)
            shell_config_file="$HOME/.bash_profile"
            ;;
        zsh)
            # Prefer .zshrc for zsh configuration
            shell_config_file="$HOME/.zshrc"
            ;;
        *)
            log_error "Unsupported shell for configuration: $shell_name"
            return 1
            ;;
    esac
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "[DRY RUN] Would configure $shell_name shell"
        log_info "[DRY RUN] Would add asdf configuration to $shell_config_file"
        log_info "[DRY RUN] Would add asdf shims to PATH"
        return 0
    fi
    
    # Determine asdf source path based on installation method
    local asdf_source=""
    local asdf_completion=""
    
    case $OS in
        macos)
            # Homebrew installation paths
            if [[ -f "/opt/homebrew/opt/asdf/libexec/asdf.sh" ]]; then
                # Apple Silicon
                asdf_source=". /opt/homebrew/opt/asdf/libexec/asdf.sh"
                if [[ "$shell_name" == "bash" ]]; then
                    asdf_completion=". /opt/homebrew/opt/asdf/etc/bash_completion.d/asdf.bash"
                fi
            elif [[ -f "/usr/local/opt/asdf/libexec/asdf.sh" ]]; then
                # Intel
                asdf_source=". /usr/local/opt/asdf/libexec/asdf.sh"
                if [[ "$shell_name" == "bash" ]]; then
                    asdf_completion=". /usr/local/opt/asdf/etc/bash_completion.d/asdf.bash"
                fi
            else
                log_warn "Could not find Homebrew asdf installation for shell integration"
                return 0
            fi
            ;;
        debian-based|alpine)
            # Git installation path (standard method for Linux)
            asdf_source=". $ASDF_DIR/asdf.sh"
            if [[ "$shell_name" == "bash" ]]; then
                asdf_completion=". $ASDF_DIR/completions/asdf.bash"
            fi
            ;;
    esac
    
    # Prepare configuration content
    local config_header="# asdf configuration (added by init/scripts/prepare)"
    local path_export='export PATH="${ASDF_DATA_DIR:-$HOME/.asdf}/shims:$PATH"'
    
    # Add configuration to shell file
    if [[ -f "$shell_config_file" ]]; then
        if ! grep -q "asdf" "$shell_config_file"; then
            log_info "Adding asdf configuration to $shell_config_file"
            echo "" >> "$shell_config_file"
            echo "$config_header" >> "$shell_config_file"
            echo "$path_export" >> "$shell_config_file"
            echo "$asdf_source" >> "$shell_config_file"
            
            # Add completion for bash
            if [[ -n "$asdf_completion" ]]; then
                echo "$asdf_completion" >> "$shell_config_file"
            fi
        else
            log_info "asdf configuration already present in $shell_config_file"
        fi
    else
        log_info "Creating $shell_config_file with asdf configuration"
        echo "$config_header" > "$shell_config_file"
        echo "$path_export" >> "$shell_config_file"
        echo "$asdf_source" >> "$shell_config_file"
        
        if [[ -n "$asdf_completion" ]]; then
            echo "$asdf_completion" >> "$shell_config_file"
        fi
    fi
    
    log_success "Shell integration setup completed for $shell_name"
    log_info "Configuration added to: $shell_config_file"
}

# Verify environment is ready
verify_environment() {
    log_info "Verifying environment setup..."
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "[DRY RUN] Would verify all tools and project setup"
        return 0
    fi
    
    # Check that all required tools are available
    local tools=("git" "asdf")
    if [[ "$OS" == "macos" ]]; then
        tools+=("brew")
    fi
    
    for tool in "${tools[@]}"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            log_error "Verification failed: $tool not found in PATH"
            exit 1
        fi
    done
    
    # Check project directory exists and has required files
    if [[ ! -d "$PROJECT_DIR" ]]; then
        log_error "Verification failed: Project directory not found at $PROJECT_DIR"
        exit 1
    fi
    
    if [[ ! -f "$PROJECT_DIR/.tool-versions" ]]; then
        log_error "Verification failed: .tool-versions not found in project directory"
        exit 1
    fi
    
    # Check asdf plugins are installed
    cd "$PROJECT_DIR"
    local required_plugins=("python" "uv")
    for plugin in "${required_plugins[@]}"; do
        if ! asdf plugin list | grep -q "^$plugin$"; then
            log_error "Verification failed: asdf plugin '$plugin' not installed"
            exit 1
        fi
    done
    cd - >/dev/null
    
    log_success "Environment verification completed"
}

# Display next steps
show_next_steps() {
    log_success "Bootstrap completed successfully!"
    echo
    
    # Check if we're running in the target shell after a potential switch
    local current_shell default_shell
    current_shell=$(ps -p $$ -o comm= | sed 's/^-//')
    default_shell=$(basename "$SHELL")
    
    log_debug "Current running shell: $current_shell"
    log_debug "Default shell: $default_shell"
    log_debug "Selected shell: ${SELECTED_SHELL:-auto-detected}"
    
    # Provide different instructions based on shell situation
    if [[ -n "$SELECTED_SHELL" ]]; then
        if [[ "$current_shell" == "$SELECTED_SHELL" && "$default_shell" == "$SELECTED_SHELL" ]]; then
            # Best case: we're running in the target shell and it's the default
            log_info "✓ Shell configuration completed for $SELECTED_SHELL"
            log_info "✓ Currently running in $SELECTED_SHELL"
            log_info "✓ Default shell is set to $SELECTED_SHELL"
            echo
            log_info "Your environment is ready! To load the new configuration:"
            echo "  source ~/.${SELECTED_SHELL}rc"
            echo
        elif [[ "$current_shell" == "$SELECTED_SHELL" ]]; then
            # We're in the target shell but it might not be the system default yet
            log_info "✓ Shell configuration completed for $SELECTED_SHELL"
            log_info "✓ Currently running in $SELECTED_SHELL"
            echo
            log_info "Your environment is ready! To load the new configuration:"
            echo "  source ~/.${SELECTED_SHELL}rc"
            echo
            if [[ "$default_shell" != "$SELECTED_SHELL" ]]; then
                log_warn "Note: Your system default shell is still $default_shell"
                log_warn "The change will take effect after logging out and back in"
            fi
        else
            # We're not in the target shell - this shouldn't happen with the new logic but handle it
            log_warn "Configuration completed for $SELECTED_SHELL, but currently running $current_shell"
            echo
            log_info "To access your configured environment:"
            echo "  1. Switch to $SELECTED_SHELL:"
            case "$SELECTED_SHELL" in
                zsh) echo "     exec zsh" ;;
                bash) echo "     exec bash" ;;
            esac
            echo "  2. Load the configuration:"
            echo "     source ~/.${SELECTED_SHELL}rc"
            echo
        fi
    else
        # No specific shell was selected
        log_info "Shell configuration completed for your current shell"
        echo
        log_info "To load the new configuration:"
        if [[ "$current_shell" == "zsh" ]]; then
            echo "  source ~/.zshrc"
        else
            echo "  source ~/.bash_profile"
        fi
        echo
    fi
    
    log_info "Next steps to complete the setup:"
    echo "  1. cd $PROJECT_DIR"
    echo "  2. direnv allow"
    echo "  3. asdf install"
    echo "  4. ansible-playbook -k playbook.yml"
    echo
    log_info "The system is now ready for full configuration via Ansible!"
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            --dry-run)
                DRY_RUN="true"
                log_info "Dry run mode enabled - no changes will be made"
                shift
                ;;
            --debug)
                DEBUG="true"
                log_info "Debug mode enabled"
                shift
                ;;
            --shell=*)
                SELECTED_SHELL="${1#*=}"
                case "$SELECTED_SHELL" in
                    bash|zsh)
                        log_info "Selected shell: $SELECTED_SHELL"
                        ;;
                    *)
                        log_error "Unsupported shell: $SELECTED_SHELL"
                        log_error "Supported shells: bash, zsh"
                        exit 1
                        ;;
                esac
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                log_error "Use --help for usage information"
                exit 1
                ;;
        esac
    done
}

# Main execution function
main() {
    # Parse command line arguments
    parse_args "$@"
    
    log_info "Starting OS bootstrap process (version $SCRIPT_VERSION)"
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "DRY RUN MODE - No changes will be made"
    fi
    echo
    
    # Detect platform and check prerequisites
    detect_platform
    check_prerequisites
    echo
    
    # Install and configure shell if specified
    if [[ -n "$SELECTED_SHELL" ]]; then
        install_shell "$SELECTED_SHELL"
        echo
    fi
    
    # Install required tools
    install_git
    echo
    
    install_asdf
    echo
    
    if [[ "$OS" == "macos" ]]; then
        install_homebrew
        echo
    fi
    
    # Setup project and environment
    setup_project
    echo
    
    setup_shell_integration
    echo
    
    # Final verification
    verify_environment
    echo
    
    # Show next steps
    if [[ "${DRY_RUN:-}" != "true" ]]; then
        show_next_steps
    else
        log_info "Dry run completed - no changes were made"
    fi
}

# Set up error handling and execute main function
trap cleanup_on_error ERR
trap cleanup_on_interrupt INT TERM
main "$@"
