#!/bin/bash
# scripts/prepare - Bootstrap script for OS initialization
# This script prepares a minimal environment for OS initialization and configuration
set -euo pipefail

# Configuration
readonly SCRIPT_VERSION="1.0.0"
readonly ASDF_VERSION="v0.14.0"
readonly PROJECT_REPO="https://github.com/geoffjay/init"
readonly PROJECTS_DIR="$HOME/Projects"
readonly PROJECT_DIR="$PROJECTS_DIR/init"
readonly ASDF_DIR="$HOME/.asdf"

# Global variables
OS=""
PKG_MGR=""
ARCH=""

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Show help information
show_help() {
    cat << EOF
OS Bootstrap Script (version $SCRIPT_VERSION)

DESCRIPTION:
    This script prepares a minimal environment for OS initialization and configuration.
    It installs git, asdf, and homebrew (on macOS), then clones the project repository.

USAGE:
    $0 [OPTIONS]

OPTIONS:
    -h, --help      Show this help message
    -v, --version   Show version information
    --dry-run       Show what would be done without making changes
    --debug         Enable debug output

ENVIRONMENT VARIABLES:
    ALLOW_ROOT      Set to 'true' to allow running as root (not recommended)
    PROJECT_REPO    Override the default project repository URL

SUPPORTED PLATFORMS:
    - Ubuntu, Debian, Pop!_OS (apt-based)
    - Alpine Linux (apk-based)  
    - macOS (with Homebrew)

EXAMPLES:
    # Standard installation
    $0

    # Run via web (typical usage)
    wget -q -O - https://raw.githubusercontent.com/geoffjay/init/main/scripts/prepare | bash

    # Dry run to see what would be installed
    $0 --dry-run

For more information, visit: https://github.com/geoffjay/init
EOF
}

# Show version information
show_version() {
    echo "OS Bootstrap Script version $SCRIPT_VERSION"
    echo "asdf version: $ASDF_VERSION"
    echo "Project repository: $PROJECT_REPO"
}

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

log_debug() {
    if [[ "${DEBUG:-}" == "true" ]]; then
        echo -e "${YELLOW}[DEBUG]${NC} $*" >&2
    fi
}

# Cleanup function for error handling
cleanup_on_error() {
    local exit_code=$?
    log_error "Script failed with exit code $exit_code"
    log_error "Cleaning up any partial installations..."
    
    # Remove partial asdf installation if it exists but is broken
    if [[ -d "$ASDF_DIR" ]] && ! command -v asdf >/dev/null 2>&1; then
        log_warn "Removing partial asdf installation at $ASDF_DIR"
        rm -rf "$ASDF_DIR" || true
    fi
    
    log_error "Bootstrap process failed. Please check the error messages above."
    log_error "You can re-run this script after fixing any issues."
    exit $exit_code
}

# Handle interruption signals
cleanup_on_interrupt() {
    log_warn "Script interrupted by user"
    cleanup_on_error
}

# Platform detection
detect_platform() {
    log_info "Detecting platform..."
    log_debug "OSTYPE: $OSTYPE"
    
    # Detect architecture
    ARCH=$(uname -m)
    log_debug "Architecture: $ARCH"
    case $ARCH in
        x86_64|amd64) ARCH="x86_64" ;;
        arm64|aarch64) ARCH="arm64" ;;
        *) 
            log_error "Unsupported architecture: $ARCH"
            exit 1
            ;;
    esac
    
    # Detect OS
    if [[ "$OSTYPE" == "darwin"* ]]; then
        OS="macos"
        log_info "Detected macOS ($ARCH)"
    elif [[ -f /etc/os-release ]]; then
        # Source the os-release file
        . /etc/os-release
        log_debug "OS ID: $ID, Pretty Name: ${PRETTY_NAME:-$ID}"
        case $ID in
            ubuntu|debian|pop)
                OS="debian-based"
                PKG_MGR="apt"
                log_info "Detected $PRETTY_NAME (Debian-based, $ARCH)"
                ;;
            alpine)
                OS="alpine"
                PKG_MGR="apk"
                log_info "Detected $PRETTY_NAME (Alpine, $ARCH)"
                ;;
            *)
                log_error "Unsupported Linux distribution: ${PRETTY_NAME:-$ID} ($ID)"
                log_error "Supported distributions: Ubuntu, Debian, Pop!_OS, Alpine Linux"
                exit 1
                ;;
        esac
    else
        log_error "Unsupported operating system: $OSTYPE"
        log_error "Supported systems: Linux (Ubuntu/Debian/Pop!_OS/Alpine), macOS"
        exit 1
    fi
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    # Check for internet connectivity
    log_debug "Testing connectivity to GitHub..."
    if ! curl -s --head --connect-timeout 10 https://github.com >/dev/null; then
        log_error "No internet connectivity or GitHub is unreachable"
        log_error "This script requires internet access to download tools"
        exit 1
    fi
    log_debug "Internet connectivity verified"
    
    # Check if running as root (warn but allow with ALLOW_ROOT)
    if [[ $EUID -eq 0 ]]; then
        if [[ "${ALLOW_ROOT:-}" != "true" ]]; then
            log_warn "Running as root is not recommended"
            log_warn "If you must run as root, set ALLOW_ROOT=true environment variable"
            log_warn "Continuing in 5 seconds... (Ctrl+C to cancel)"
            sleep 5
        else
            log_warn "Running as root (ALLOW_ROOT=true set)"
        fi
    fi
    
    # Check for required system commands
    local required_commands=("curl" "tar")
    if [[ "$OS" != "alpine" ]]; then
        required_commands+=("sudo")
    fi
    
    for cmd in "${required_commands[@]}"; do
        log_debug "Checking for command: $cmd"
        if ! command -v "$cmd" >/dev/null 2>&1; then
            log_error "Required command not found: $cmd"
            exit 1
        fi
    done
    
    # Check disk space (require at least 1GB free)
    local available_space
    if command -v df >/dev/null 2>&1; then
        available_space=$(df "$HOME" | tail -1 | awk '{print $4}')
        log_debug "Available disk space: ${available_space}KB"
        if [[ $available_space -lt 1048576 ]]; then # 1GB in KB
            log_warn "Low disk space detected (less than 1GB available)"
            log_warn "Installation may fail due to insufficient space"
        fi
    fi
    
    log_success "Prerequisites check completed"
}

# Verify tool installation
verify_installation() {
    local tool=$1
    local version_cmd=$2
    
    if ! command -v "$tool" >/dev/null 2>&1; then
        log_error "$tool installation failed or not in PATH"
        return 1
    fi
    
    if [[ -n "$version_cmd" ]]; then
        local version_output
        version_output=$(eval "$version_cmd" 2>/dev/null || echo "version check failed")
        log_success "$tool installed successfully ($version_output)"
    else
        log_success "$tool installed successfully"
    fi
    
    return 0
}

# Install git
install_git() {
    log_info "Installing git..."
    
    # Check if git is already installed
    if command -v git >/dev/null 2>&1; then
        local git_version
        git_version=$(git --version 2>/dev/null || echo "unknown")
        log_info "git is already installed ($git_version)"
        return 0
    fi
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "[DRY RUN] Would install git via $PKG_MGR"
        return 0
    fi
    
    case $OS in
        debian-based)
            log_info "Updating package cache..."
            sudo apt update -qq
            log_info "Installing git via apt..."
            sudo apt install -y git
            ;;
        alpine)
            log_info "Updating package cache..."
            if [[ $EUID -eq 0 ]]; then
                apk update
                apk add git
            else
                sudo apk update
                sudo apk add git
            fi
            ;;
        macos)
            # On macOS, git is usually installed with Xcode command line tools
            if ! command -v git >/dev/null 2>&1; then
                log_info "Installing Xcode command line tools..."
                xcode-select --install
                log_info "Please complete the Xcode command line tools installation and re-run this script"
                exit 1
            fi
            ;;
    esac
    
    verify_installation "git" "git --version"
}

# Install asdf
install_asdf() {
    log_info "Installing asdf..."
    
    # Check if asdf is already installed
    if [[ -d "$ASDF_DIR" ]] && command -v asdf >/dev/null 2>&1; then
        local asdf_version
        asdf_version=$(asdf version 2>/dev/null || echo "unknown")
        log_info "asdf is already installed ($asdf_version)"
        return 0
    fi
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "[DRY RUN] Would clone asdf to $ASDF_DIR"
        log_info "[DRY RUN] Would install asdf plugins: python, uv, direnv"
        return 0
    fi
    
    # Remove existing asdf directory if it exists but is broken
    if [[ -d "$ASDF_DIR" ]]; then
        log_warn "Removing existing asdf directory (appears to be broken)"
        rm -rf "$ASDF_DIR"
    fi
    
    # Clone asdf repository
    log_info "Cloning asdf repository..."
    git clone https://github.com/asdf-vm/asdf.git "$ASDF_DIR" --branch "$ASDF_VERSION"
    
    # Add asdf to PATH for this script
    export PATH="$ASDF_DIR/bin:$PATH"
    
    # Source asdf
    # shellcheck source=/dev/null
    . "$ASDF_DIR/asdf.sh"
    
    # Install required asdf plugins
    log_info "Installing asdf plugins..."
    
    # Install python plugin
    if ! asdf plugin list | grep -q "^python$"; then
        asdf plugin add python
        log_success "Added python plugin to asdf"
    else
        log_info "python plugin already installed"
    fi
    
    # Install uv plugin  
    if ! asdf plugin list | grep -q "^uv$"; then
        asdf plugin add uv
        log_success "Added uv plugin to asdf"
    else
        log_info "uv plugin already installed"
    fi
    
    # Install direnv plugin
    if ! asdf plugin list | grep -q "^direnv$"; then
        asdf plugin add direnv
        log_success "Added direnv plugin to asdf"
    else
        log_info "direnv plugin already installed"
    fi
    
    verify_installation "asdf" "asdf version"
}

# Install Homebrew (macOS only)
install_homebrew() {
    log_info "Installing Homebrew..."
    
    # Check if brew is already installed
    if command -v brew >/dev/null 2>&1; then
        local brew_version
        brew_version=$(brew --version | head -n1 2>/dev/null || echo "unknown")
        log_info "Homebrew is already installed ($brew_version)"
        return 0
    fi
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "[DRY RUN] Would install Homebrew"
        return 0
    fi
    
    # Install Homebrew
    log_info "Downloading and installing Homebrew..."
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    
    # Add Homebrew to PATH for this script
    if [[ -f "/opt/homebrew/bin/brew" ]]; then
        # Apple Silicon
        export PATH="/opt/homebrew/bin:$PATH"
    elif [[ -f "/usr/local/bin/brew" ]]; then
        # Intel
        export PATH="/usr/local/bin:$PATH"
    fi
    
    verify_installation "brew" "brew --version | head -n1"
}

# Setup project environment
setup_project() {
    log_info "Setting up project environment..."
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "[DRY RUN] Would create directory: $PROJECTS_DIR"
        log_info "[DRY RUN] Would clone repository: $PROJECT_REPO"
        return 0
    fi
    
    # Create Projects directory if it doesn't exist
    if [[ ! -d "$PROJECTS_DIR" ]]; then
        log_info "Creating Projects directory at $PROJECTS_DIR"
        mkdir -p "$PROJECTS_DIR"
    else
        log_info "Projects directory already exists at $PROJECTS_DIR"
    fi
    
    # Clone project repository if it doesn't exist
    if [[ ! -d "$PROJECT_DIR" ]]; then
        log_info "Cloning project repository..."
        git clone "$PROJECT_REPO" "$PROJECT_DIR"
        log_success "Project cloned to $PROJECT_DIR"
    else
        log_info "Project directory already exists at $PROJECT_DIR"
        # Update existing repository
        log_info "Updating existing repository..."
        cd "$PROJECT_DIR"
        git pull origin main || git pull origin master || log_warn "Could not update repository"
        cd - >/dev/null
    fi
    
    # Verify project structure
    if [[ ! -f "$PROJECT_DIR/.tool-versions" ]]; then
        log_error "Project appears to be incomplete (missing .tool-versions)"
        log_error "Please check the repository: $PROJECT_REPO"
        exit 1
    fi
    
    log_success "Project environment setup completed"
}

# Setup shell integration
setup_shell_integration() {
    log_info "Setting up shell integration..."
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "[DRY RUN] Would add asdf configuration to shell RC file"
        return 0
    fi
    
    local shell_rc=""
    local shell_name=""
    
    # Determine shell configuration file
    if [[ -n "${BASH_VERSION:-}" ]]; then
        shell_name="bash"
        shell_rc="$HOME/.bashrc"
    elif [[ -n "${ZSH_VERSION:-}" ]]; then
        shell_name="zsh"
        shell_rc="$HOME/.zshrc"
    else
        # Try to detect from SHELL environment variable
        case "${SHELL:-}" in
            */bash) shell_name="bash"; shell_rc="$HOME/.bashrc" ;;
            */zsh) shell_name="zsh"; shell_rc="$HOME/.zshrc" ;;
            *) 
                log_warn "Could not detect shell, skipping shell integration"
                return 0
                ;;
        esac
    fi
    
    log_info "Detected shell: $shell_name"
    
    # Add asdf to shell configuration
    local asdf_config="# asdf configuration (added by init/scripts/prepare)"
    local asdf_source=". $ASDF_DIR/asdf.sh"
    
    if [[ -f "$shell_rc" ]]; then
        if ! grep -q "asdf.sh" "$shell_rc"; then
            log_info "Adding asdf to $shell_rc"
            echo "" >> "$shell_rc"
            echo "$asdf_config" >> "$shell_rc"
            echo "$asdf_source" >> "$shell_rc"
            
            # Add completion for bash
            if [[ "$shell_name" == "bash" ]]; then
                echo ". $ASDF_DIR/completions/asdf.bash" >> "$shell_rc"
            fi
        else
            log_info "asdf configuration already present in $shell_rc"
        fi
    else
        log_info "Creating $shell_rc with asdf configuration"
        echo "$asdf_config" > "$shell_rc"
        echo "$asdf_source" >> "$shell_rc"
        
        if [[ "$shell_name" == "bash" ]]; then
            echo ". $ASDF_DIR/completions/asdf.bash" >> "$shell_rc"
        fi
    fi
    
    log_success "Shell integration setup completed"
}

# Verify environment is ready
verify_environment() {
    log_info "Verifying environment setup..."
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "[DRY RUN] Would verify all tools and project setup"
        return 0
    fi
    
    # Check that all required tools are available
    local tools=("git" "asdf")
    if [[ "$OS" == "macos" ]]; then
        tools+=("brew")
    fi
    
    for tool in "${tools[@]}"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            log_error "Verification failed: $tool not found in PATH"
            exit 1
        fi
    done
    
    # Check project directory exists and has required files
    if [[ ! -d "$PROJECT_DIR" ]]; then
        log_error "Verification failed: Project directory not found at $PROJECT_DIR"
        exit 1
    fi
    
    if [[ ! -f "$PROJECT_DIR/.tool-versions" ]]; then
        log_error "Verification failed: .tool-versions not found in project directory"
        exit 1
    fi
    
    # Check asdf plugins are installed
    cd "$PROJECT_DIR"
    local required_plugins=("python" "uv")
    for plugin in "${required_plugins[@]}"; do
        if ! asdf plugin list | grep -q "^$plugin$"; then
            log_error "Verification failed: asdf plugin '$plugin' not installed"
            exit 1
        fi
    done
    cd - >/dev/null
    
    log_success "Environment verification completed"
}

# Display next steps
show_next_steps() {
    log_success "Bootstrap completed successfully!"
    echo
    log_info "Next steps:"
    echo "  1. Restart your shell or run: source ~/.bashrc (or ~/.zshrc)"
    echo "  2. cd $PROJECT_DIR"
    echo "  3. direnv allow"
    echo "  4. asdf install"
    echo "  5. ansible-playbook -k playbook.yml"
    echo
    log_info "The system is now ready for full configuration via Ansible!"
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            --dry-run)
                DRY_RUN="true"
                log_info "Dry run mode enabled - no changes will be made"
                shift
                ;;
            --debug)
                DEBUG="true"
                log_info "Debug mode enabled"
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                log_error "Use --help for usage information"
                exit 1
                ;;
        esac
    done
}

# Main execution function
main() {
    # Parse command line arguments
    parse_args "$@"
    
    log_info "Starting OS bootstrap process (version $SCRIPT_VERSION)"
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "DRY RUN MODE - No changes will be made"
    fi
    echo
    
    # Detect platform and check prerequisites
    detect_platform
    check_prerequisites
    echo
    
    # Install required tools
    install_git
    echo
    
    install_asdf
    echo
    
    if [[ "$OS" == "macos" ]]; then
        install_homebrew
        echo
    fi
    
    # Setup project and environment
    setup_project
    echo
    
    setup_shell_integration
    echo
    
    # Final verification
    verify_environment
    echo
    
    # Show next steps
    if [[ "${DRY_RUN:-}" != "true" ]]; then
        show_next_steps
    else
        log_info "Dry run completed - no changes were made"
    fi
}

# Set up error handling and execute main function
trap cleanup_on_error ERR
trap cleanup_on_interrupt INT TERM
main "$@"
