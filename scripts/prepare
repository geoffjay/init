#!/bin/bash
# scripts/prepare - Bootstrap script for OS initialization
# This script prepares a minimal environment for OS initialization and configuration
set -euo pipefail

# Configuration
readonly SCRIPT_VERSION="1.0.0"
readonly ASDF_VERSION="v0.18.0"
readonly PROJECT_REPO="https://github.com/geoffjay/init"
readonly PROJECTS_DIR="$HOME/Projects"
readonly PROJECT_DIR="$PROJECTS_DIR/init"
readonly ASDF_DIR="$HOME/.asdf"

# Global variables
OS=""
PKG_MGR=""
ARCH=""
SELECTED_SHELL=""

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Show help information
show_help() {
    cat << EOF
OS Bootstrap Script (version $SCRIPT_VERSION)

DESCRIPTION:
    This script prepares a minimal environment for OS initialization and configuration.
    It installs git, Python build dependencies, asdf (via Homebrew on macOS, binary download on Linux), 
    direnv, and homebrew (on macOS), then clones the project repository.

USAGE:
    $0 [OPTIONS]

OPTIONS:
    -h, --help          Show this help message
    -v, --version       Show version information
    --dry-run           Show what would be done without making changes
    --debug             Enable debug output
    --shell=SHELL       Select shell to install, set as default, and configure (bash|zsh)
                        If different from current shell, you'll be prompted to continue
                        in the new shell or complete setup in the current shell
                        Default: auto-detect current shell

ENVIRONMENT VARIABLES:
    ALLOW_ROOT      Set to 'true' to allow running as root (not recommended)
    PROJECT_REPO    Override the default project repository URL

SUPPORTED PLATFORMS:
    - Ubuntu, Debian, Pop!_OS (apt-based)
    - Alpine Linux (apk-based)  
    - macOS (with Homebrew)

EXAMPLES:
    # Standard installation
    $0

    # Run via web (typical usage)
    wget -q -O - https://raw.githubusercontent.com/geoffjay/init/main/scripts/prepare | bash

    # Install and configure zsh as the shell
    $0 --shell=zsh

    # Install and configure bash as the shell
    $0 --shell=bash

    # Dry run to see what would be installed
    $0 --dry-run

For more information, visit: https://github.com/geoffjay/init
EOF
}

# Show version information
show_version() {
    echo "OS Bootstrap Script version $SCRIPT_VERSION"
    echo "asdf version: $ASDF_VERSION"
    echo "Project repository: $PROJECT_REPO"
}

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

log_debug() {
    if [[ "${DEBUG:-}" == "true" ]]; then
        echo -e "${YELLOW}[DEBUG]${NC} $*" >&2
    fi
}

# Cleanup function for error handling
cleanup_on_error() {
    local exit_code=$?
    log_error "Script failed with exit code $exit_code"
    log_error "Cleaning up any partial installations..."
    
    # Remove partial asdf installation if it exists but is broken
    if [[ -d "$ASDF_DIR" ]] && ! command -v asdf >/dev/null 2>&1; then
        log_warn "Removing partial asdf data directory at $ASDF_DIR"
        rm -rf "$ASDF_DIR" || true
    fi
    
    log_error "Bootstrap process failed. Please check the error messages above."
    log_error "You can re-run this script after fixing any issues."
    exit $exit_code
}

# Handle interruption signals
cleanup_on_interrupt() {
    log_warn "Script interrupted by user"
    cleanup_on_error
}

# Platform detection
detect_platform() {
    log_info "Detecting platform..."
    log_debug "OSTYPE: $OSTYPE"
    
    # Detect architecture
    ARCH=$(uname -m)
    log_debug "Architecture: $ARCH"
    case $ARCH in
        x86_64|amd64) ARCH="x86_64" ;;
        arm64|aarch64) ARCH="arm64" ;;
        *) 
            log_error "Unsupported architecture: $ARCH"
            exit 1
            ;;
    esac
    
    # Detect OS
    if [[ "$OSTYPE" == "darwin"* ]]; then
        OS="macos"
        log_info "Detected macOS ($ARCH)"
    elif [[ -f /etc/os-release ]]; then
        # Source the os-release file
        . /etc/os-release
        log_debug "OS ID: $ID, Pretty Name: ${PRETTY_NAME:-$ID}"
        case $ID in
            ubuntu|debian|pop)
                OS="debian-based"
                PKG_MGR="apt"
                log_info "Detected $PRETTY_NAME (Debian-based, $ARCH)"
                ;;
            alpine)
                OS="alpine"
                PKG_MGR="apk"
                log_info "Detected $PRETTY_NAME (Alpine, $ARCH)"
                ;;
            *)
                log_error "Unsupported Linux distribution: ${PRETTY_NAME:-$ID} ($ID)"
                log_error "Supported distributions: Ubuntu, Debian, Pop!_OS, Alpine Linux"
                exit 1
                ;;
        esac
    else
        log_error "Unsupported operating system: $OSTYPE"
        log_error "Supported systems: Linux (Ubuntu/Debian/Pop!_OS/Alpine), macOS"
        exit 1
    fi
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    # Check for internet connectivity
    log_debug "Testing connectivity to GitHub..."
    if ! curl -s --head --connect-timeout 10 https://github.com >/dev/null; then
        log_error "No internet connectivity or GitHub is unreachable"
        log_error "This script requires internet access to download tools"
        exit 1
    fi
    log_debug "Internet connectivity verified"
    
    # Check if running as root (warn but allow with ALLOW_ROOT)
    if [[ $EUID -eq 0 ]]; then
        if [[ "${ALLOW_ROOT:-}" != "true" ]]; then
            log_warn "Running as root is not recommended"
            log_warn "If you must run as root, set ALLOW_ROOT=true environment variable"
            log_warn "Continuing in 5 seconds... (Ctrl+C to cancel)"
            sleep 5
        else
            log_warn "Running as root (ALLOW_ROOT=true set)"
        fi
    fi
    
    # Check for required system commands
    local required_commands=("curl" "tar")
    if [[ "$OS" != "alpine" ]]; then
        required_commands+=("sudo")
    fi
    
    for cmd in "${required_commands[@]}"; do
        log_debug "Checking for command: $cmd"
        if ! command -v "$cmd" >/dev/null 2>&1; then
            log_error "Required command not found: $cmd"
            exit 1
        fi
    done
    
    # Check disk space (require at least 1GB free)
    local available_space
    if command -v df >/dev/null 2>&1; then
        available_space=$(df "$HOME" | tail -1 | awk '{print $4}')
        log_debug "Available disk space: ${available_space}KB"
        if [[ $available_space -lt 1048576 ]]; then # 1GB in KB
            log_warn "Low disk space detected (less than 1GB available)"
            log_warn "Installation may fail due to insufficient space"
        fi
    fi
    
    log_success "Prerequisites check completed"
}

# Verify tool installation
verify_installation() {
    local tool=$1
    local version_cmd=$2
    
    if ! command -v "$tool" >/dev/null 2>&1; then
        log_error "$tool installation failed or not in PATH"
        return 1
    fi
    
    if [[ -n "$version_cmd" ]]; then
        local version_output
        version_output=$(eval "$version_cmd" 2>/dev/null || echo "version check failed")
        log_success "$tool installed successfully ($version_output)"
    else
        log_success "$tool installed successfully"
    fi
    
    return 0
}

# Install shell
install_shell() {
    local target_shell="$1"
    log_info "Installing and configuring shell: $target_shell"
    
    # Check what shell we're currently running in
    local current_running_shell
    # Try multiple methods to detect the current shell
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        current_running_shell="zsh"
    elif [[ -n "${BASH_VERSION:-}" ]]; then
        current_running_shell="bash"
    else
        # Fall back to checking parent process
        local parent_pid
        parent_pid=$(ps -o ppid= -p $$ 2>/dev/null | tr -d ' ')
        if [[ -n "$parent_pid" ]]; then
            current_running_shell=$(ps -p "$parent_pid" -o comm= 2>/dev/null | sed 's/^-//' || echo "unknown")
        else
            current_running_shell="unknown"
        fi
    fi
    
    # Check the system's default shell setting
    local system_default_shell
    system_default_shell=$(basename "$SHELL")
    
    log_debug "Currently running shell: $current_running_shell"
    log_debug "Target shell: $target_shell"
    log_debug "System default shell (SHELL env var): $system_default_shell"
    
    # Check if shell is already installed
    if command -v "$target_shell" >/dev/null 2>&1; then
        local shell_version
        case "$target_shell" in
            bash)
                shell_version=$(bash --version | head -n1 2>/dev/null || echo "unknown")
                ;;
            zsh)
                shell_version=$(zsh --version 2>/dev/null || echo "unknown")
                ;;
        esac
        log_info "$target_shell is already installed ($shell_version)"
    else
        if [[ "${DRY_RUN:-}" == "true" ]]; then
            log_info "[DRY RUN] Would install $target_shell via $PKG_MGR"
        else
            log_info "Installing $target_shell..."
            case $OS in
                debian-based)
                    sudo apt update -qq
                    sudo apt install -y "$target_shell"
                    ;;
                alpine)
                    if [[ $EUID -eq 0 ]]; then
                        apk update
                        apk add "$target_shell"
                    else
                        sudo apk update
                        sudo apk add "$target_shell"
                    fi
                    ;;
                macos)
                    # bash and zsh are usually pre-installed on macOS
                    if ! command -v "$target_shell" >/dev/null 2>&1; then
                        log_info "Installing $target_shell via Homebrew..."
                        brew install "$target_shell"
                    fi
                    ;;
            esac
            
            verify_installation "$target_shell" ""
        fi
    fi
    
    # Check if we're already running in the target shell
    if [[ "$current_running_shell" == "$target_shell" ]]; then
        log_info "Already running in $target_shell"
        
        # Still check if we need to set it as the system default
        if [[ "$system_default_shell" != "$target_shell" ]]; then
            if [[ "${DRY_RUN:-}" == "true" ]]; then
                log_info "[DRY RUN] Would set $target_shell as system default shell"
            else
                log_info "Setting $target_shell as system default shell..."
                local shell_path
                shell_path=$(command -v "$target_shell")
                
                # Add shell to /etc/shells if not already present
                if ! grep -q "^$shell_path$" /etc/shells 2>/dev/null; then
                    log_info "Adding $shell_path to /etc/shells"
                    echo "$shell_path" | sudo tee -a /etc/shells >/dev/null
                fi
                
                # Change user's default shell
                if command -v chsh >/dev/null 2>&1; then
                    chsh -s "$shell_path"
                    log_success "System default shell set to $target_shell"
                    log_info "Note: The change will take effect for new login sessions"
                else
                    log_warn "chsh command not available - you may need to change your shell manually"
                fi
            fi
        else
            log_info "$target_shell is already the system default shell"
        fi
        return 0
    fi
    
    # We need to switch to the target shell
    if [[ "$system_default_shell" != "$target_shell" ]]; then
        if [[ "${DRY_RUN:-}" == "true" ]]; then
            log_info "[DRY RUN] Would change system default shell from $system_default_shell to $target_shell"
            log_info "[DRY RUN] Would prompt user about continuing with shell switch"
        else
            log_info "Setting $target_shell as system default shell..."
            local shell_path
            shell_path=$(command -v "$target_shell")
            
            # Add shell to /etc/shells if not already present
            if ! grep -q "^$shell_path$" /etc/shells 2>/dev/null; then
                log_info "Adding $shell_path to /etc/shells"
                echo "$shell_path" | sudo tee -a /etc/shells >/dev/null
            fi
            
            # Change user's default shell
            if command -v chsh >/dev/null 2>&1; then
                chsh -s "$shell_path"
                log_success "System default shell changed to $target_shell"
                
                # Ask user how they want to proceed
                echo
                log_warn "SHELL CHANGE DETECTED:"
                log_warn "You've switched from $system_default_shell to $target_shell as your default shell."
                log_warn "Currently running: $current_running_shell → switching to: $target_shell"
                echo
                echo "To continue the bootstrap process, you have two options:"
                echo
                echo "  Option A: Continue in the new shell (recommended)"
                echo "            This will re-run the script using $target_shell"
                echo
                echo "  Option B: Complete bootstrap in current shell, then logout/login"
                echo "            Configuration will be applied to $target_shell but you'll need"
                echo "            to logout and login for it to take effect"
                echo
                echo -n "Which option would you prefer? [A/b]: "
                read -r choice
                choice=${choice:-A}
                
                case "$choice" in
                    [Aa]*)
                        log_info "Continuing bootstrap process in $target_shell..."
                        echo
                        # Re-execute the script with the same arguments in the new shell
                        local script_args=()
                        # Reconstruct the original arguments
                        [[ "${DRY_RUN:-}" == "true" ]] && script_args+=("--dry-run")
                        [[ "${DEBUG:-}" == "true" ]] && script_args+=("--debug")
                        [[ -n "$SELECTED_SHELL" ]] && script_args+=("--shell=$SELECTED_SHELL")
                        
                        # Get the full path to the current script
                        local script_path
                        script_path=$(realpath "$0")
                        
                        log_info "Executing: exec $shell_path $script_path ${script_args[*]}"
                        exec "$shell_path" "$script_path" "${script_args[@]}"
                        ;;
                    [Bb]*)
                        log_info "Continuing bootstrap in current shell..."
                        log_warn "Remember to logout and login after completion for shell change to take effect"
                        echo
                        ;;
                    *)
                        log_warn "Invalid choice, continuing in current shell..."
                        echo
                        ;;
                esac
            else
                log_warn "chsh command not available - you may need to change your shell manually"
            fi
        fi
    else
        # System default is already correct, just need to switch running shell
        if [[ "${DRY_RUN:-}" == "true" ]]; then
            log_info "[DRY RUN] Would switch from $current_running_shell to $target_shell"
        else
            log_info "Switching from $current_running_shell to $target_shell..."
            local shell_path
            shell_path=$(command -v "$target_shell")
            
            # Re-execute the script with the same arguments in the new shell
            local script_args=()
            [[ "${DRY_RUN:-}" == "true" ]] && script_args+=("--dry-run")
            [[ "${DEBUG:-}" == "true" ]] && script_args+=("--debug")
            [[ -n "$SELECTED_SHELL" ]] && script_args+=("--shell=$SELECTED_SHELL")
            
            # Get the full path to the current script
            local script_path
            script_path=$(realpath "$0")
            
            log_info "Executing: exec $shell_path $script_path ${script_args[*]}"
            exec "$shell_path" "$script_path" "${script_args[@]}"
        fi
    fi
}

# Install git
install_git() {
    log_info "Installing git..."
    
    # Check if git is already installed
    if command -v git >/dev/null 2>&1; then
        local git_version
        git_version=$(git --version 2>/dev/null || echo "unknown")
        log_info "git is already installed ($git_version)"
        return 0
    fi
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "[DRY RUN] Would install git via $PKG_MGR"
        return 0
    fi
    
    case $OS in
        debian-based)
            log_info "Updating package cache..."
            sudo apt update -qq
            log_info "Installing git via apt..."
            sudo apt install -y git
            ;;
        alpine)
            log_info "Updating package cache..."
            if [[ $EUID -eq 0 ]]; then
                apk update
                apk add git
            else
                sudo apk update
                sudo apk add git
            fi
            ;;
        macos)
            # On macOS, git is usually installed with Xcode command line tools
            if ! command -v git >/dev/null 2>&1; then
                log_info "Installing Xcode command line tools..."
                xcode-select --install
                log_info "Please complete the Xcode command line tools installation and re-run this script"
                exit 1
            fi
            ;;
    esac
    
    verify_installation "git" "git --version"
}

# Install asdf
install_asdf() {
    log_info "Installing asdf..."
    
    # Check if asdf is already installed and working
    if command -v asdf >/dev/null 2>&1; then
        local asdf_version
        asdf_version=$(asdf version 2>/dev/null || echo "unknown")
        log_info "asdf is already installed ($asdf_version)"
        
        # Source asdf if not already sourced (for plugin installation)
        # Note: Binary installations don't need sourcing, only Homebrew installations do
        if [[ -z "${ASDF_DIR_WAS_SET:-}" ]]; then
            # Try to source existing asdf installation (Homebrew only)
            if [[ -f "/opt/homebrew/opt/asdf/libexec/asdf.sh" ]]; then
                # shellcheck source=/dev/null
                . "/opt/homebrew/opt/asdf/libexec/asdf.sh" 2>/dev/null || true
                export ASDF_DIR_WAS_SET=1
            elif [[ -f "/usr/local/opt/asdf/libexec/asdf.sh" ]]; then
                # shellcheck source=/dev/null
                . "/usr/local/opt/asdf/libexec/asdf.sh" 2>/dev/null || true
                export ASDF_DIR_WAS_SET=1
            fi
            # For binary installations, no sourcing is needed
            export ASDF_DIR_WAS_SET=1
        fi
        
        # Install plugins even if asdf is already installed
        install_asdf_plugins
        return 0
    fi
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        case $OS in
            macos)
                log_info "[DRY RUN] Would install asdf via Homebrew"
                ;;
            debian-based|alpine)
                log_info "[DRY RUN] Would install asdf via binary download to /usr/local/bin"
                ;;
        esac
        log_info "[DRY RUN] Would install asdf plugins: python, uv"
        return 0
    fi
    
    # Install asdf using appropriate method for each platform
    case $OS in
        macos)
            log_info "Installing asdf via Homebrew..."
            brew install asdf
            
            # Source asdf for this script only if not already sourced
            if [[ -z "${ASDF_DIR_WAS_SET:-}" ]]; then
                if [[ -f "/opt/homebrew/opt/asdf/libexec/asdf.sh" ]]; then
                    # Apple Silicon
                    # shellcheck source=/dev/null
                    . "/opt/homebrew/opt/asdf/libexec/asdf.sh"
                    export ASDF_DIR_WAS_SET=1
                elif [[ -f "/usr/local/opt/asdf/libexec/asdf.sh" ]]; then
                    # Intel
                    # shellcheck source=/dev/null
                    . "/usr/local/opt/asdf/libexec/asdf.sh"
                    export ASDF_DIR_WAS_SET=1
                else
                    log_error "Could not find asdf installation after Homebrew install"
                    exit 1
                fi
            fi
            ;;
        debian-based|alpine)
            log_info "Installing asdf via binary download (Linux)..."
            install_asdf_from_binary
            return 0
            ;;
    esac
    
    # Install required asdf plugins
    install_asdf_plugins
    
    verify_installation "asdf" "asdf version"
}

# Install asdf from binary distribution
install_asdf_from_binary() {
    log_info "Installing asdf from pre-compiled binary..."
    
    # Map architecture to binary naming convention
    local binary_arch
    case $ARCH in
        x86_64) binary_arch="amd64" ;;
        arm64) binary_arch="arm64" ;;
        *) 
            log_error "Unsupported architecture for binary installation: $ARCH"
            exit 1
            ;;
    esac
    
    # Construct download URL
    local binary_filename="asdf-${ASDF_VERSION}-linux-${binary_arch}.tar.gz"
    local download_url="https://github.com/asdf-vm/asdf/releases/download/${ASDF_VERSION}/${binary_filename}"
    
    # Create temporary directory for download and extraction
    local temp_dir=$(mktemp -d)
    local temp_archive="$temp_dir/$binary_filename"
    
    log_info "Downloading asdf binary: $binary_filename"
    log_debug "Download URL: $download_url"
    log_debug "Temporary directory: $temp_dir"
    
    # Download the binary archive
    if ! curl -L -o "$temp_archive" "$download_url"; then
        log_error "Failed to download asdf binary from $download_url"
        rm -rf "$temp_dir"
        exit 1
    fi
    
    # Extract the archive
    log_info "Extracting asdf binary..."
    if ! tar -xzf "$temp_archive" -C "$temp_dir"; then
        log_error "Failed to extract asdf binary archive"
        rm -rf "$temp_dir"
        exit 1
    fi
    
    # Find the asdf binary in the extracted files
    local asdf_binary
    asdf_binary=$(find "$temp_dir" -name "asdf" -type f -executable)
    if [[ -z "$asdf_binary" ]]; then
        log_error "Could not find asdf binary in extracted archive"
        rm -rf "$temp_dir"
        exit 1
    fi
    
    log_debug "Found asdf binary at: $asdf_binary"
    
    # Copy the binary to /usr/local/bin (requires sudo on most systems)
    log_info "Installing asdf binary to /usr/local/bin..."
    if [[ $EUID -eq 0 ]]; then
        # Running as root, can copy directly
        cp "$asdf_binary" /usr/local/bin/asdf
        chmod +x /usr/local/bin/asdf
    else
        # Need sudo to copy to /usr/local/bin
        if command -v sudo >/dev/null 2>&1; then
            sudo cp "$asdf_binary" /usr/local/bin/asdf
            sudo chmod +x /usr/local/bin/asdf
        else
            log_error "Need sudo to install asdf to /usr/local/bin, but sudo is not available"
            log_error "Please run this script as root or install sudo"
            rm -rf "$temp_dir"
            exit 1
        fi
    fi
    
    # Clean up temporary files
    rm -rf "$temp_dir"
    
    # Verify the installation
    if ! command -v asdf >/dev/null 2>&1; then
        log_error "asdf installation failed - binary not found in PATH"
        exit 1
    fi
    
    # Add /usr/local/bin to PATH for this script if not already there
    if [[ ":$PATH:" != *":/usr/local/bin:"* ]]; then
        export PATH="/usr/local/bin:$PATH"
        log_debug "Added /usr/local/bin to PATH for this script"
    fi
    
    log_success "asdf binary installed successfully"
    
    # Install required asdf plugins
    install_asdf_plugins
    
    verify_installation "asdf" "asdf version"
}

# Install required asdf plugins
install_asdf_plugins() {
    log_info "Installing asdf plugins..."
    
    # Install python plugin
    if ! asdf plugin list | grep -q "^python$"; then
        log_info "Adding python plugin..."
        asdf plugin add python
        log_success "Added python plugin to asdf"
    else
        log_info "python plugin already installed"
    fi
    
    # Install uv plugin  
    if ! asdf plugin list | grep -q "^uv$"; then
        log_info "Adding uv plugin..."
        asdf plugin add uv
        log_success "Added uv plugin to asdf"
    else
        log_info "uv plugin already installed"
    fi
}

# Install Python build dependencies
install_python_build_deps() {
    log_info "Installing Python build dependencies..."
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        case $OS in
            macos)
                log_info "[DRY RUN] Would install Python build dependencies via Homebrew"
                ;;
            debian-based)
                log_info "[DRY RUN] Would install Python build dependencies via apt"
                ;;
            alpine)
                log_info "[DRY RUN] Would install Python build dependencies via apk"
                ;;
        esac
        return 0
    fi
    
    # Install Python build dependencies using appropriate package manager
    case $OS in
        macos)
            log_info "Installing Python build dependencies via Homebrew..."
            # For macOS, Homebrew typically handles most dependencies automatically
            # The key ones for Python compilation are openssl, readline, sqlite, xz, zlib
            brew install openssl readline sqlite3 xz zlib
            ;;
        debian-based)
            log_info "Installing Python build dependencies via apt..."
            local packages=(
                "libssl-dev"      # SSL/TLS support
                "libbz2-dev"      # bzip2 compression
                "liblzma-dev"     # LZMA compression
                "libsqlite3-dev"  # SQLite database
                "libreadline-dev" # readline support
                "libncurses-dev"  # ncurses for terminal handling
            )
            
            if [[ $EUID -eq 0 ]]; then
                apt update && apt install -y "${packages[@]}"
            else
                sudo apt update && sudo apt install -y "${packages[@]}"
            fi
            ;;
        alpine)
            log_info "Installing Python build dependencies via apk..."
            local packages=(
                "openssl-dev"    # SSL/TLS support  
                "bzip2-dev"      # bzip2 compression
                "xz-dev"         # LZMA compression
                "sqlite-dev"     # SQLite database
                "readline-dev"   # readline support
                "ncurses-dev"    # ncurses for terminal handling
            )
            
            if [[ $EUID -eq 0 ]]; then
                apk add --no-cache "${packages[@]}"
            else
                sudo apk add --no-cache "${packages[@]}"
            fi
            ;;
        *)
            log_error "Unsupported OS for Python build dependencies: $OS"
            exit 1
            ;;
    esac
    
    log_success "Python build dependencies installed successfully"
}

# Install direnv via package managers
install_direnv() {
    log_info "Installing direnv..."
    
    # Check if direnv is already installed
    if command -v direnv >/dev/null 2>&1; then
        local direnv_version
        direnv_version=$(direnv version 2>/dev/null || echo "unknown")
        log_info "direnv is already installed ($direnv_version)"
        return 0
    fi
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        case $OS in
            macos)
                log_info "[DRY RUN] Would install direnv via Homebrew"
                ;;
            debian-based)
                log_info "[DRY RUN] Would install direnv via apt"
                ;;
            alpine)
                log_info "[DRY RUN] Would install direnv via apk"
                ;;
        esac
        return 0
    fi
    
    # Install direnv using appropriate package manager
    case $OS in
        macos)
            log_info "Installing direnv via Homebrew..."
            brew install direnv
            ;;
        debian-based)
            log_info "Installing direnv via apt..."
            if [[ $EUID -eq 0 ]]; then
                apt update && apt install -y direnv
            else
                sudo apt update && sudo apt install -y direnv
            fi
            ;;
        alpine)
            log_info "Installing direnv via apk..."
            if [[ $EUID -eq 0 ]]; then
                apk add --no-cache direnv
            else
                sudo apk add --no-cache direnv
            fi
            ;;
        *)
            log_error "Unsupported OS for direnv installation: $OS"
            exit 1
            ;;
    esac
    
    verify_installation "direnv" "direnv version"
}

# Install Homebrew (macOS only)
install_homebrew() {
    log_info "Installing Homebrew..."
    
    # Check if brew is already installed
    if command -v brew >/dev/null 2>&1; then
        local brew_version
        brew_version=$(brew --version | head -n1 2>/dev/null || echo "unknown")
        log_info "Homebrew is already installed ($brew_version)"
        return 0
    fi
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "[DRY RUN] Would install Homebrew"
        return 0
    fi
    
    # Install Homebrew
    log_info "Downloading and installing Homebrew..."
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    
    # Add Homebrew to PATH for this script
    if [[ -f "/opt/homebrew/bin/brew" ]]; then
        # Apple Silicon
        export PATH="/opt/homebrew/bin:$PATH"
    elif [[ -f "/usr/local/bin/brew" ]]; then
        # Intel
        export PATH="/usr/local/bin:$PATH"
    fi
    
    verify_installation "brew" "brew --version | head -n1"
}

# Setup project environment
setup_project() {
    log_info "Setting up project environment..."
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "[DRY RUN] Would create directory: $PROJECTS_DIR"
        log_info "[DRY RUN] Would clone repository: $PROJECT_REPO"
        return 0
    fi
    
    # Create Projects directory if it doesn't exist
    if [[ ! -d "$PROJECTS_DIR" ]]; then
        log_info "Creating Projects directory at $PROJECTS_DIR"
        mkdir -p "$PROJECTS_DIR"
    else
        log_info "Projects directory already exists at $PROJECTS_DIR"
    fi
    
    # Clone project repository if it doesn't exist
    if [[ ! -d "$PROJECT_DIR" ]]; then
        log_info "Cloning project repository..."
        git clone "$PROJECT_REPO" "$PROJECT_DIR"
        log_success "Project cloned to $PROJECT_DIR"
    else
        log_info "Project directory already exists at $PROJECT_DIR"
        # Update existing repository
        log_info "Updating existing repository..."
        cd "$PROJECT_DIR"
        git pull origin main || git pull origin master || log_warn "Could not update repository"
        cd - >/dev/null
    fi
    
    # Verify project structure
    if [[ ! -f "$PROJECT_DIR/.tool-versions" ]]; then
        log_error "Project appears to be incomplete (missing .tool-versions)"
        log_error "Please check the repository: $PROJECT_REPO"
        exit 1
    fi
    
    log_success "Project environment setup completed"
}

# Setup shell integration
setup_shell_integration() {
    log_info "Setting up shell integration..."
    
    local shell_name=""
    local shell_config_file=""
    
    # Determine which shell to configure
    if [[ -n "$SELECTED_SHELL" ]]; then
        shell_name="$SELECTED_SHELL"
        log_info "Configuring selected shell: $shell_name"
    else
        # Auto-detect shell
        if [[ -n "${BASH_VERSION:-}" ]]; then
            shell_name="bash"
        elif [[ -n "${ZSH_VERSION:-}" ]]; then
            shell_name="zsh"
        else
            # Try to detect from SHELL environment variable
            case "${SHELL:-}" in
                */bash) shell_name="bash" ;;
                */zsh) shell_name="zsh" ;;
                *) 
                    log_warn "Could not detect shell, defaulting to bash"
                    shell_name="bash"
                    ;;
            esac
        fi
        log_info "Auto-detected shell: $shell_name"
    fi
    
    # Determine shell configuration file based on shell type
    case "$shell_name" in
        bash)
            shell_config_file="$HOME/.bash_profile"
            ;;
        zsh)
            # Prefer .zshrc for zsh configuration
            shell_config_file="$HOME/.zshrc"
            ;;
        *)
            log_error "Unsupported shell for configuration: $shell_name"
            return 1
            ;;
    esac
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "[DRY RUN] Would configure $shell_name shell"
        log_info "[DRY RUN] Would add development environment configuration to $shell_config_file"
        log_info "[DRY RUN] Would add asdf shims to PATH"
        log_info "[DRY RUN] Would add direnv hook to shell"
        return 0
    fi
    
    # Determine asdf source path based on installation method
    local asdf_source=""
    local asdf_completion=""
    
    case $OS in
        macos)
            # Homebrew installation paths
            if [[ -f "/opt/homebrew/opt/asdf/libexec/asdf.sh" ]]; then
                # Apple Silicon
                asdf_source=". /opt/homebrew/opt/asdf/libexec/asdf.sh"
                if [[ "$shell_name" == "bash" ]]; then
                    asdf_completion=". /opt/homebrew/opt/asdf/etc/bash_completion.d/asdf.bash"
                fi
            elif [[ -f "/usr/local/opt/asdf/libexec/asdf.sh" ]]; then
                # Intel
                asdf_source=". /usr/local/opt/asdf/libexec/asdf.sh"
                if [[ "$shell_name" == "bash" ]]; then
                    asdf_completion=". /usr/local/opt/asdf/etc/bash_completion.d/asdf.bash"
                fi
            else
                log_warn "Could not find Homebrew asdf installation for shell integration"
                return 0
            fi
            ;;
        debian-based|alpine)
            # Binary installation path (standard method for Linux)
            asdf_source="# asdf binary installed to /usr/local/bin (no sourcing required)"
            # Note: Binary installation doesn't include completion files
            asdf_completion=""
            ;;
    esac
    
    # Prepare configuration content
    local config_header="# Development environment configuration (added by init/scripts/prepare)"
    local path_export='export PATH="${ASDF_DATA_DIR:-$HOME/.asdf}/shims:$PATH"'
    local direnv_hook=""
    
    # Set up direnv hook based on shell
    case "$shell_name" in
        bash)
            direnv_hook='eval "$(direnv hook bash)"'
            ;;
        zsh)
            direnv_hook='eval "$(direnv hook zsh)"'
            ;;
    esac
    
    # Add configuration to shell file
    if [[ -f "$shell_config_file" ]]; then
        if ! grep -q "init/scripts/prepare" "$shell_config_file"; then
            log_info "Adding development environment configuration to $shell_config_file"
            echo "" >> "$shell_config_file"
            echo "$config_header" >> "$shell_config_file"
            echo "" >> "$shell_config_file"
            echo "# asdf configuration" >> "$shell_config_file"
            echo "$path_export" >> "$shell_config_file"
            echo "$asdf_source" >> "$shell_config_file"
            
            # Add completion for bash
            if [[ -n "$asdf_completion" ]]; then
                echo "$asdf_completion" >> "$shell_config_file"
            fi
            
            # Add direnv hook
            echo "" >> "$shell_config_file"
            echo "# direnv configuration" >> "$shell_config_file"
            echo "$direnv_hook" >> "$shell_config_file"
        else
            log_info "Development environment configuration already present in $shell_config_file"
        fi
    else
        log_info "Creating $shell_config_file with development environment configuration"
        echo "$config_header" > "$shell_config_file"
        echo "" >> "$shell_config_file"
        echo "# asdf configuration" >> "$shell_config_file"
        echo "$path_export" >> "$shell_config_file"
        echo "$asdf_source" >> "$shell_config_file"
        
        if [[ -n "$asdf_completion" ]]; then
            echo "$asdf_completion" >> "$shell_config_file"
        fi
        
        # Add direnv hook
        echo "" >> "$shell_config_file"
        echo "# direnv configuration" >> "$shell_config_file"
        echo "$direnv_hook" >> "$shell_config_file"
    fi
    
    log_success "Shell integration setup completed for $shell_name"
    log_info "Configuration added to: $shell_config_file"
}

# Verify environment is ready
verify_environment() {
    log_info "Verifying environment setup..."
    
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "[DRY RUN] Would verify all tools and project setup"
        return 0
    fi
    
    # Check that all required tools are available
    local tools=("git" "asdf" "direnv")
    if [[ "$OS" == "macos" ]]; then
        tools+=("brew")
    fi
    
    for tool in "${tools[@]}"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            log_error "Verification failed: $tool not found in PATH"
            exit 1
        fi
    done
    
    # Check project directory exists and has required files
    if [[ ! -d "$PROJECT_DIR" ]]; then
        log_error "Verification failed: Project directory not found at $PROJECT_DIR"
        exit 1
    fi
    
    if [[ ! -f "$PROJECT_DIR/.tool-versions" ]]; then
        log_error "Verification failed: .tool-versions not found in project directory"
        exit 1
    fi
    
    # Check asdf plugins are installed
    cd "$PROJECT_DIR"
    local required_plugins=("python" "uv")
    for plugin in "${required_plugins[@]}"; do
        if ! asdf plugin list | grep -q "^$plugin$"; then
            log_error "Verification failed: asdf plugin '$plugin' not installed"
            exit 1
        fi
    done
    cd - >/dev/null
    
    log_success "Environment verification completed"
}

# Display next steps
show_next_steps() {
    log_success "Bootstrap completed successfully!"
    echo
    
    # Check if we're running in the target shell after a potential switch
    local current_shell default_shell
    current_shell=$(ps -p $$ -o comm= | sed 's/^-//')
    default_shell=$(basename "$SHELL")
    
    log_debug "Current running shell: $current_shell"
    log_debug "Default shell: $default_shell"
    log_debug "Selected shell: ${SELECTED_SHELL:-auto-detected}"
    
    # Provide different instructions based on shell situation
    if [[ -n "$SELECTED_SHELL" ]]; then
        if [[ "$current_shell" == "$SELECTED_SHELL" && "$default_shell" == "$SELECTED_SHELL" ]]; then
            # Best case: we're running in the target shell and it's the default
            log_info "✓ Shell configuration completed for $SELECTED_SHELL"
            log_info "✓ Currently running in $SELECTED_SHELL"
            log_info "✓ Default shell is set to $SELECTED_SHELL"
            echo
            log_info "Your environment is ready! To load the new configuration:"
            echo "  source ~/.${SELECTED_SHELL}rc"
            echo
        elif [[ "$current_shell" == "$SELECTED_SHELL" ]]; then
            # We're in the target shell but it might not be the system default yet
            log_info "✓ Shell configuration completed for $SELECTED_SHELL"
            log_info "✓ Currently running in $SELECTED_SHELL"
            echo
            log_info "Your environment is ready! To load the new configuration:"
            echo "  source ~/.${SELECTED_SHELL}rc"
            echo
            if [[ "$default_shell" != "$SELECTED_SHELL" ]]; then
                log_warn "Note: Your system default shell is still $default_shell"
                log_warn "The change will take effect after logging out and back in"
            fi
        else
            # We're not in the target shell - this shouldn't happen with the new logic but handle it
            log_warn "Configuration completed for $SELECTED_SHELL, but currently running $current_shell"
            echo
            log_info "To access your configured environment:"
            echo "  1. Switch to $SELECTED_SHELL:"
            case "$SELECTED_SHELL" in
                zsh) echo "     exec zsh" ;;
                bash) echo "     exec bash" ;;
            esac
            echo "  2. Load the configuration:"
            echo "     source ~/.${SELECTED_SHELL}rc"
            echo
        fi
    else
        # No specific shell was selected
        log_info "Shell configuration completed for your current shell"
        echo
        log_info "To load the new configuration:"
        if [[ "$current_shell" == "zsh" ]]; then
            echo "  source ~/.zshrc"
        else
            echo "  source ~/.bash_profile"
        fi
        echo
    fi
    
    log_info "Next steps to complete the setup:"
    echo "  1. cd $PROJECT_DIR"
    echo "  2. direnv allow"
    echo "  3. asdf install"
    echo "  4. ansible-playbook -k playbook.yml"
    echo
    log_info "The system is now ready for full configuration via Ansible!"
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            --dry-run)
                DRY_RUN="true"
                log_info "Dry run mode enabled - no changes will be made"
                shift
                ;;
            --debug)
                DEBUG="true"
                log_info "Debug mode enabled"
                shift
                ;;
            --shell=*)
                SELECTED_SHELL="${1#*=}"
                case "$SELECTED_SHELL" in
                    bash|zsh)
                        log_info "Selected shell: $SELECTED_SHELL"
                        ;;
                    *)
                        log_error "Unsupported shell: $SELECTED_SHELL"
                        log_error "Supported shells: bash, zsh"
                        exit 1
                        ;;
                esac
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                log_error "Use --help for usage information"
                exit 1
                ;;
        esac
    done
}

# Main execution function
main() {
    # Parse command line arguments
    parse_args "$@"
    
    log_info "Starting OS bootstrap process (version $SCRIPT_VERSION)"
    if [[ "${DRY_RUN:-}" == "true" ]]; then
        log_info "DRY RUN MODE - No changes will be made"
    fi
    echo
    
    # Detect platform and check prerequisites
    detect_platform
    check_prerequisites
    echo
    
    # Install and configure shell if specified
    if [[ -n "$SELECTED_SHELL" ]]; then
        install_shell "$SELECTED_SHELL"
        echo
    fi
    
    # Install required tools
    install_git
    echo
    
    install_python_build_deps
    echo
    
    install_asdf
    echo
    
    install_direnv
    echo
    
    if [[ "$OS" == "macos" ]]; then
        install_homebrew
        echo
    fi
    
    # Setup project and environment
    setup_project
    echo
    
    setup_shell_integration
    echo
    
    # Final verification
    verify_environment
    echo
    
    # Show next steps
    if [[ "${DRY_RUN:-}" != "true" ]]; then
        show_next_steps
    else
        log_info "Dry run completed - no changes were made"
    fi
}

# Set up error handling and execute main function
trap cleanup_on_error ERR
trap cleanup_on_interrupt INT TERM
main "$@"
